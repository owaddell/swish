#!/usr/bin/env swish

;;; Copyright 2018 Beckman Coulter, Inc.
;;;
;;; Permission is hereby granted, free of charge, to any person
;;; obtaining a copy of this software and associated documentation
;;; files (the "Software"), to deal in the Software without
;;; restriction, including without limitation the rights to use, copy,
;;; modify, merge, publish, distribute, sublicense, and/or sell copies
;;; of the Software, and to permit persons to whom the Software is
;;; furnished to do so, subject to the following conditions:
;;;
;;; The above copyright notice and this permission notice shall be
;;; included in all copies or substantial portions of the Software.
;;;
;;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
;;; EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
;;; MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
;;; NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
;;; HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
;;; WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
;;; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
;;; DEALINGS IN THE SOFTWARE.

(define verbosity (make-parameter 0))

(define help-sections '(all details examples))

(define escape-hatch
  (cli-specs
   ["explicit-source" -- (list . "<source>") "source filename"]))

(define shared-cli
  (cli-specs
   ["verbose" -v count "show more compiler messages"]
   ["output-file" -o (string "<output>") "write output to <output>"]
   ["libdirs" -L (list "<libdir>") "add <libdir> to library-directories"]
   ["srcdirs" -s (list "<srcdir>") "add <srcdir> to source-directories"]
   ["rt-libs" --rtlib (list "<lib>" ...)
    '("visit compiled libraries <lib> ... before compiling <source>;"
      "these libraries are added to <output> unless otherwise"
      "specified, in which case they must be provided at run time")]
   ["help" -h --help (list "[<section>]" ...)
    (format "display help, <section>={~{~a~^|~}}" help-sections)]
   ))

(define library-cli
  (cli-specs
   ["source-file" (string "<source>") "library source filename (or -- <source>)"]
   ["as-library" --library bool "make a compiled library; <output> omits --rtlib libraries"
    (usage show req)]))

(define app-cli
  (cli-specs
   ["source-file" (string "<source>") "program source filename (or -- <source>)"]
   ["component" -c bool "make component; <output> omits --rtlib libraries"
    (conflicts '("boot-files"))]
   ["boot-files" -b (list "<boot-file>")
    "make stand-alone program including <boot-file>"]
   ["libs-visible" --libs-visible bool
    "make imported libraries visible to eval"]))

(define swish-lib?
  (let ([libs (filter (lambda (lib) (match lib [(swish . ,_) #t] [,_ #f])) (library-list))])
    (lambda (lib)
      (member lib libs))))

(define swish-libdir (path-parent (osi_get_executable_path)))

(define (system-libdir swish-wpo?)
  (path-combine swish-libdir (if swish-wpo? "wpo" "lib")))

(define minimal-library-filename
  (get-real-path (path-combine swish-libdir "minimal.library")))

(define swish-library-filename
  (get-real-path (path-combine swish-libdir "swish.library")))

(define (swish-library-file? full-path)
  (or (string=? full-path minimal-library-filename)
      (string=? full-path swish-library-filename)))

(define prevent-wpo (make-hashtable equal-hash equal?))

(define (library-setup swish-wpo? libdirs rt-libs)
  (when swish-wpo?
    ;; Allow whole-program optimization for swish libraries in stand-alone
    ;; programs, but not in libraries or compiled scripts where we'll be loading
    ;; the swish boot file.
    (for-each
     (lambda (lib)
       (match lib
         [(swish . ,_) (hashtable-set! prevent-wpo lib #f)]
         [,_ (void)]))
     (library-list)))
  ;; Disallow whole-program optimization for (swish app-params) and its
  ;; dependencies so we can bake these libraries into the boot file for
  ;; a stand-alone application where they can be used in the boot process.
  (let forbid! ([lib* '((swish app-params))])
    (match lib*
      [(,lib . ,more)
       (hashtable-set! prevent-wpo lib #t)
       (forbid! (library-requirements lib))
       (forbid! more)]
      [() (void)]))
  ;; visit --rtlib libraries (even swish libraries, so library-object-filename
  ;; points to a swish library file instead of swish.boot)
  (for-each visit rt-libs)
  ;; Disallow whole-program optimization for --rtlib libraries that will
  ;; be loaded separately at run time.
  (for-each
   (lambda (lib)
     (unless (hashtable-contains? prevent-wpo lib)
       (hashtable-set! prevent-wpo lib #t)))
   (library-list))
  (library-directories (cons (system-libdir swish-wpo?) libdirs))
  (when (> (verbosity) 1)
    (printf "Library directories:\n~{ ~s\n~}" (library-directories))))

(define who (path-last (car (command-line))))

(define (fail fmt . args) (apply errorf who fmt args))

(define (wrap indent . texts)
  (wrap-text (current-output-port)
    (- (help-wrap-width) indent) indent indent (join texts #\space)))

(define-syntax example
  (syntax-rules ()
    [(_ (call ...) text ...)
     (begin
       (wrap 2 call ... "\n")
       (wrap 4 text ... "\n"))]))

(define-syntax any-sections
  (syntax-rules ()
    [(_ requested [(key ...) body ...] ...)
     (let ([sections requested])
       (define thunks
         (remq #f
           (list
            (and (ormap (lambda (x) (memq x sections)) '(key ...))
                 (lambda () body ...))
            ...)))
       (do ([ps thunks (cdr ps)] [sep "" "\n"]) ((null? ps))
         (display sep)
         ((car ps))))]))

(define (list-item item . texts)
  (printf "~4@a " item)
  (wrap-text (current-output-port) (- (help-wrap-width) 6) 0 5 (join texts #\space))
  (newline))

(define (usage short? sections ht)
  (define selected
    (cond
     [(pair? sections) sections]
     [short? '(usage)]
     [else '(usage help)]))
  (any-sections selected
    [(all usage)
     (display-usage "Usage:" who (append shared-cli app-cli))
     (display-usage "   or:" who (append shared-cli library-cli))]
    [(all help)
     (when ht (hashtable-delete! ht "help"))
     (display-options shared-cli ht)
     (printf "\n  Program target options:\n")
     (display-options app-cli ht)
     (printf "\n  Library target options:\n")
     (display-options library-cli ht)]
    [(all details)
     (define csvNNN.dll
       (format "csv~{~a~}.dll"
         (call-with-values scheme-version-number list)))
     (wrap 0
       who "can make a compiled library, a component program, a stand-alone program, or a linked program."
       "By default," who "creates a linked program.\n"
       "\n"
       "To compile a library, specify --library. The resulting compiled library may"
       "be loaded explicitly or used as a" who "--rtlib argument when compiling other"
       "libraries or programs.\n"
       "\n"
       "To create a component program, specify -c. A component program does not run on"
       "its own, but may be loaded by another program.\n"
       "\n"
       "When" who "creates a compiled library or component program, the resulting <output> contains"
       "compiled code for <source>  and the user libraries it references, but excludes"
       "built-in libraries and libraries supplied via --rtlib.\n"
       "\n"
       "To create a stand-alone program, specify -b and provide a base boot file."
       who "creates a stand-alone program"
       "by copying the" software-internal-name "executable to <out-file>"
       "and creating a boot file <out-file>.boot containing each"
       (format "-b~aboot-file" #\240)
       "in order, the run-time libraries included via --rtlib,"
       "the libraries required by <source>, and the compiled code"
       "for <source>.\n"
       "\n"
       "When run, a stand-alone program:\n")
     (list-item "1." "loads Chez Scheme's " csvNNN.dll " [Windows only],")
     (list-item "2." "loads the program boot file, then")
     (list-item "3." "invokes a custom scheme-start handler described below.\n")
     (wrap 0
       "To create a linked program, omit the -b option.\n\n"
       "When run, a linked program calls" software-internal-name "to:\n")
     (list-item "1." "load Chez Scheme's " csvNNN.dll " [Windows only],")
     (list-item "2." "load Chez Scheme's petite.boot and scheme.boot,")
     (list-item "3." "load the standard" software-internal-name "boot file, then")
     (list-item "4." "invoke the" software-internal-name "scheme-start handler.\n")
     (wrap 0 "The scheme-start handler of a linked program or stand-alone program:\n")
     (list-item "1." "sets app:name, app:path, command-line, and command-line-arguments")
     (list-item "2." "installs an exception handler that prints app:name, if non-false, and")
     (list-item "3." "invokes the compiled program code.")
     (wrap 0
       "\n"
       "Compiling a linked program or stand-alone program incorporates any --rtlib libraries"
       "directly into the <output> file."
       "If a program loads other compiled libraries explicitly at run time, it must also load"
       "any --rtlib libraries they require."
       "The compiler skips --rtlib libraries during whole-library or whole-program"
       "optimization.\n")]
    [(all examples)
     (printf "Examples:\n")
     (newline)
     (example (who "-o foo -b petite foo.ss")
       "builds a stand-alone \"foo\" executable from \"foo.ss\""
       "using the same petite.boot that swish uses.\n")
     (example (who "-o foo -b petite -b scheme foo.ss")
       "builds a stand-alone \"foo\" executable from \"foo.ss\" using"
       "the same petite.boot and scheme.boot that swish uses."
       "If we specified only -b scheme, the resulting foo.boot would"
       "not be truly stand-alone, since scheme.boot requires petite.boot.\n")
     (example (who "-o foo -b petite -b scheme --rtlib swish foo.ss")
       "builds a stand-alone \"foo\" executable from \"foo.ss\" using the"
       "same petite.boot and scheme.boot that swish uses and makes the"
       "standard swish libraries available at run time, so that \"foo\""
       "can compile code that uses those libraries.\n")
     (example (who "-o foo.library --library foo.ss")
       "compiles the \"foo.ss\" library to \"foo.library\" and generates"
       "\"foo.wpo\" for use by whole-program optimization.\n")
     (example (who "-c bar.ss -o bar.component --rtlib foo.library bar.library")
       "compiles the \"bar.ss\" program to \"bar.component\", which expects"
       "\"foo.library\" and \"bar.library\" to be provided at run time.")
     ])
  (let ([invalid (fold-right remq sections help-sections)])
    (unless (null? invalid)
      (fail "unrecognized help section~p:~{ ~a~}" (length invalid) invalid)))
  (exit 0))

(define-syntax target-case
  (syntax-rules ()
    [(_ expr [(k0 k1 ...) e0 e1 ...] ...)
     ;; require all cases
     (equal? '(component library linked stand-alone)
       (sort (lambda (a b) (string<? (symbol->string a) (symbol->string b)))
         (apply append (datum ((k0 k1 ...) ...)))))
     (let ([target expr])
       (case expr
         [(k0 k1 ...) e0 e1 ...] ...
         [else (match target)]))]))

(define (parse-library lib)
  (parameterize ([library-directories lib])
    (library-directories)))

;; create tmp file:
;;  - on the same filesystem as basis, else rename-path will fail
;;  - with known extension, since compile-whole-program replaces
;;    extension with .wpo
(define (tmp-filename basis)
  (format "~a-~36r.tmp" (path-root basis)
    (bytevector-uint-ref (osi_make_uuid) 0 'little 16)))

(define (change-extension fn new-ext)
  (string-append (path-root fn) new-ext))

(define (copy ip op)
  (define buflen (expt 2 16))
  (define buf (make-bytevector buflen))
  (let cp ()
    (let ([n (get-bytevector-n! ip buf 0 buflen)])
      (unless (eof-object? n)
        (put-bytevector op buf 0 n)
        (cp)))))

(define (copy-to output-fn . input-fn*)
  ;; open-file applies mode #o777 only when creating the file, so first remove
  (rm-f output-fn)
  (let ([op (open-file output-fn (+ O_WRONLY O_CREAT) #o777 'binary-output)])
    (on-exit (close-port op)
      (for-each
       (lambda (input-fn)
         (let ([ip (open-file input-fn O_RDONLY 0 'binary-input)])
           (on-exit (close-port ip)
             (copy ip op))))
       input-fn*))))

(define (rm-f filename)
  (catch (remove-file filename)))

;; wrap contents of source-fn in a top-level program with standard imports
(define (do-compile-program source-fn dest)
  (with-sfd-source-offset source-fn
    (lambda (ip sfd source-offset)
      (define annotated-source
        (get-datum/annotations-all ip sfd source-offset))
      (define program
        ;; source-fn must not use top-level-program, since it is spliced in as body
        `(top-level-program
          (import (scheme) (swish imports))
          ,@annotated-source))
      (compile-to-file (list program) dest sfd))))

(define (compile-help source-fn tmp-out target-type)
  (target-case target-type
    [(library)
     (compile-library source-fn tmp-out)]
    [(component linked stand-alone)
     (do-compile-program source-fn tmp-out)]))

(define (compile-wpo wpo-file output-fn libs-visible? target-type)
  (target-case target-type
    [(library)
     (let ([missing (compile-whole-library wpo-file output-fn)])
       (rename-path wpo-file (change-extension output-fn ".wpo"))
       missing)]
    [(component linked stand-alone)
     (let ([missing (compile-whole-program wpo-file output-fn libs-visible?)])
       (rm-f wpo-file)
       missing)]))

(define (do-compile source-fn output-fn libs-visible? swish-wpo? target-type)
  (let ([tmp (tmp-filename source-fn)])
    (on-exit (rm-f tmp)
      (when (> (verbosity) 0) (printf "compiling ~a\n" (opt "source-file")))
      (generate-wpo-files #t)
      (compile-imported-libraries #t)
      (compile-file-message #f)
      ;; We add ".wpo" variants to the front of library-extensions so that the
      ;; expander forces library compilation if a ".wpo" file exists and is
      ;; older than the source file, while still falling back on the usual
      ;; object file if the ".wpo" file is not wanted, e.g., for the --rtlib
      ;; case.  When the expander calls compile-library-handler, we restore the
      ;; ".so" extension so that compile-library can build both the ".so" file
      ;; and its ".wpo" by-product without conflict.
      (parameterize ([library-extensions
                      (append
                       (map (lambda (x)
                              (match-let* ([(,src . ,obj) x])
                                (cons src (change-extension obj ".wpo"))))
                         (library-extensions))
                       (library-extensions))]
                     [compile-library-handler
                      (lambda (source dest)
                        (when (> (verbosity) 0) (printf "compiling ~a\n" source))
                        (compile-library source (change-extension dest ".so")))])
        (compile-help source-fn tmp target-type))
      (let* ([wpo-file (change-extension tmp ".wpo")]
             [default-library-search (library-search-handler)]
             [libs
              (parameterize ([library-search-handler
                              (lambda (who path dir* all-ext*)
                                (if (ormap (lambda (p) (match p [(,_ . ".wpo") #t] [,_ #f])) all-ext*)
                                    (if (hashtable-ref prevent-wpo path #f)
                                        (values #f #f #f)
                                        (default-library-search who path dir* all-ext*))
                                    (match (catch (library-object-filename path))
                                      [,obj-file
                                       (guard (string? obj-file))
                                       (values #f obj-file (file-exists? obj-file))]
                                      [,_
                                       (default-library-search who path dir* all-ext*)])))])
                (compile-wpo wpo-file output-fn libs-visible? target-type))]
             [missing-libs
              ;; Stand-alone program should have found all required non-swish libraries.
              ;; If swish libraries are incorporated via whole-program optimization,
              ;; then we must also have found the wpo files for those libraries.
              ;; Dependent programs can use swish libraries included in runtime,
              ;; as can stand-alone programs that explicitly specify --rtlib swish.
              (if swish-wpo?
                  libs
                  (remp swish-lib? libs))])
        missing-libs))))

(define boot-file-map
  (let ([cache #f])
    (lambda ()
      (unless cache
        (set! cache (build-boot-file-map)))
      cache)))

(define (build-boot-file-map)
  (let-values ([(to-stdin from-stdout from-stderr os-pid)
                (spawn-os-process (osi_get_executable_path) '("--verbose") self)])
    (close-port to-stdin)
    (let ([from-stderr (binary->utf8 from-stderr)])
      (let lp ([als '()])
        (let ([line (get-line from-stderr)])
          (if (eof-object? line)
              als
              (lp
               (match (pregexp-match "^trying (.*)\\.\\.\\.opened\r?$" line)
                 [(,_ ,fn)
                  (cons (cons (path-last fn) fn) als)]
                 [,_ als]))))))))

(define (resolve-boot-file boot)
  (cond
   [(regular-file? boot) boot]
   [(assoc boot (boot-file-map)) => cdr]
   [(assoc (string-append boot ".boot") (boot-file-map)) => cdr]
   [else (fail "cannot resolve boot file ~a" boot)]))

(define (find-rt-lib rt-lib lib-dirs)
  (if (regular-file? rt-lib)
      (get-real-path rt-lib)
      (ormap (lambda (lib-dir)
               (let ([filename (path-combine (cdr lib-dir) rt-lib)])
                 (and (regular-file? filename)
                      (get-real-path filename))))
        lib-dirs)))

;; resolve to real path name; expand system libraries; preserve order; keep first occurence
(define (resolve-rt-libs rt-lib* lib-dirs)
  (define (cons-unique rt-lib ls)
    (if (member rt-lib ls)
        ls
        (cons rt-lib ls)))
  (define (add ls rt-lib)
    (cond
     [(find-rt-lib rt-lib lib-dirs) =>
      (lambda (filename) (cons-unique filename ls))]
     [(equal? rt-lib "swish")
      (cons-unique swish-library-filename
        (cons-unique minimal-library-filename ls))]
     [else (fail "cannot resolve --rtlib ~s" rt-lib)]))
  (reverse (fold-left add '() rt-lib*)))

(define (resolve-missing-libs target-type rt-libs missing-libs)
  (let ([ht (make-hashtable string-hash string=?)])
    (for-each
     (lambda (lib)
       (match (catch (library-object-filename lib))
         [#(EXIT ,reason) (errorf who "cannot resolve missing library ~s" lib)]
         [,filename
          (guard (string? filename))
          (let ([lib-file (get-real-path filename)])
            (unless (member lib-file rt-libs)
              (hashtable-update! ht lib-file
                (lambda (x) (cons lib x))
                '())))]))
     missing-libs)
    (let-values ([(keys vals) (hashtable-entries ht)])
      (when (> (verbosity) 0)
        (unless (equal? vals '#())
          (target-case target-type
            [(component)
             (printf "The following libraries may be needed at run time:~{ ~s~}\n"
               (vector->list keys))]
            [(linked stand-alone)
             (printf "Added without whole-program optimization:~{ ~s~}\n"
               (apply append (vector->list vals)))]
            [(library)
             (raise "TODO probably need to merge resolve-missing-libs with report-required\n")])))
      (vector->list keys))))

(define (show-files target-type app-boot boot-files rt-libs other-libs source-fn)
  (when (> (verbosity) 1)
    (printf "making ~a program~@[ boot file ~s~] from:" target-type app-boot)
    (printf "~@[~{\n-b      ~a~}~]" boot-files)
    (printf "~{\n--rtlib ~a~}" rt-libs)
    (printf "~{\n        ~a~}" other-libs)
    (printf "\n        ~a\n" source-fn)))

(define (report-required missing-libs rt-libs)
  (define ht (make-hashtable string-hash string=?))
  (define no-file-key "")
  (for-each
   (lambda (lib)
     (match (catch (library-object-filename lib))
       [,obj-file
        (guard (string? obj-file))
        (hashtable-update! ht obj-file
          (lambda (x) (cons lib x))
          '())]
       [,_
        (hashtable-update! ht no-file-key
          (lambda (x) (cons lib x))
          '())]))
   missing-libs)
  ;; By default, don't nag about providing the --rtlib libraries.
  (when (= (verbosity) 0)
    (for-each (lambda (rt-lib) (hashtable-delete! ht rt-lib))
      rt-libs))
  (match (sort (lambda (a b) (string<? (car a) (car b)))
           (let-values ([(keys vals) (hashtable-entries ht)])
             (map cons (vector->list keys) (vector->list vals))))
    [() (void)]
    [,to-provide
     (printf "These libraries must be provided at run time:\n")
     (for-each
      (lambda (p)
        (match p
          [(,obj-file . ,libraries)
           (printf "~a\n~@[~{  ~s\n~}~]"
             (if (equal? no-file-key obj-file)
                 "Cannot determine file that provides:"
                 obj-file)
             (and (>= (verbosity) 2) libraries))]))
      to-provide)]))

(define (try-parse)
  (define problem #f)
  (define lib-opt
    (parse-command-line-arguments
     (append escape-hatch shared-cli library-cli)
     (command-line-arguments)
     (lambda x (unless problem (set! problem x)))))
  (if (lib-opt "as-library")
      (if problem
          (apply fail problem)
          lib-opt)
      (parse-command-line-arguments (append escape-hatch shared-cli app-cli))))

(define opt (try-parse))

(cond
 [(opt "srcdirs") =>
  (lambda (srcdirs)
    (source-directories (append srcdirs (source-directories))))])

(cond
 [(zero? (hashtable-size (opt))) (usage #t '() #f)]
 [(opt "help") =>
  (lambda (sections)
    (usage #f (map string->symbol sections) (opt)))]
 [else
  (let* ([source-fn
          (or (opt "source-file")
              (match (opt "explicit-source")
                [(,source-fn) source-fn]
                [,_ #f])
              (fail "requires source filename"))]
         [output-fn
          (or (opt "output-file")
              (fail "requires output filename"))]
         [as-library? (hashtable-ref (opt) "as-library" #f)]
         [libdirs (fold-right
                   (lambda (x acc)
                     (append (parse-library x) acc))
                   (library-directories)
                   (or (opt "libdirs") '()))]
         [rt-libs (resolve-rt-libs (or (opt "rt-libs") '()) libdirs)])
    (verbosity (or (opt "verbose") 0))
    (import-notify (> (verbosity) 2))
    (cond
     [as-library?
      (library-setup #f libdirs rt-libs)
      (match (do-compile source-fn output-fn #f #f 'library)
        [() (void)]
        [,missing-libs
         (report-required missing-libs rt-libs)])]
     [else
      (let ()
        (define libs-visible? (opt "libs-visible"))
        (define target-type
          (cond
           [(opt "boot-files") 'stand-alone]
           [(opt "component") 'component]
           [else 'linked]))
        (target-case target-type
          [(stand-alone)
           ;; Add location of swish system .wpo files only if we're building a
           ;; stand-alone program (boot-files non-empty).
           (let* ([boot-files (map resolve-boot-file (opt "boot-files"))]
                  [swish-wpo?
                   (or (null? rt-libs)
                       ;; don't use wpo for swish library if we're including it as a
                       ;; run-time library, else we could duplicate code
                       (not (member swish-library-filename rt-libs)))]
                  [rt-libs
                   ;; Always include minimal.library as --rtlib and disable
                   ;; whole-program optimization for (swish app-params) and its
                   ;; dependencies since these are required by the boot process
                   ;; for stand-alone apps and we don't want to risk duplicating
                   ;; those libraries within the compiled top-level program itself.
                   (if (member minimal-library-filename rt-libs)
                       rt-libs
                       (cons minimal-library-filename rt-libs))]
                  [_ (library-setup swish-wpo? libdirs rt-libs)]
                  [other-libs
                   ;; load-compiled-from-port fails if given compressed
                   ;; - note that (port-file-compressed! ip) works only for file ports,
                   ;;   and does not work for bytevector-input-ports
                   ;; - not a problem because compile-to-file will compress us later
                   (parameterize ([compile-compressed #f])
                     (resolve-missing-libs 'stand-alone rt-libs
                       (do-compile source-fn output-fn libs-visible? swish-wpo? target-type)))]
                  [app-boot (change-extension output-fn ".boot")]
                  [compiled-code
                   (let ([ip (open-file output-fn O_RDONLY 0 'binary-input)])
                     (on-exit (close-port ip)
                       (get-bytevector-all ip)))])
             (show-files target-type app-boot boot-files rt-libs other-libs source-fn)
             ;; Arrange for scheme-start to set up parameters the way app.ss
             ;; would set them before invoking a script. In particular, set
             ;; app:name and app:path so that compiled code can use app:config,
             ;; e.g., to locate foreign code, while invoking libraries during
             ;; the preamble of the compiled code.
             ;;
             ;; This expression must not reference exports that may participate
             ;; in whole-program optimization, since that could result in
             ;; duplicate library initialization within the compiled
             ;; code. Referencing exports provided by minimal.library is fine,
             ;; since they are excluded from wpo.
             (compile-to-file
              `((suppress-greeting #t)
                (let ([orig (scheme-start)])
                  (scheme-start
                   (lambda args
                     (let ([who (vector-ref (osi_get_argv) 0)])
                       (command-line (cons who args))
                       (command-line-arguments args)
                       (app:name who)
                       (app:path who))
                     (with-exception-handler app-exception-handler
                       (lambda ()
                         (scheme-start orig)
                         (load-compiled-from-port (open-bytevector-input-port ',compiled-code))))))))
              output-fn)
             (apply make-boot-file app-boot '()
               (append boot-files rt-libs other-libs (list output-fn)))
             (copy-to output-fn (osi_get_executable_path)))]
          [(component)
           (library-setup #f libdirs rt-libs)
           (match (do-compile source-fn output-fn libs-visible? #f target-type)
             [() (void)]
             [,missing
              (when (> (verbosity) 0)
                (printf "These libraries must be provided at run time:\n~{ ~s\n~}" missing))])
           (show-files target-type #f #f rt-libs '() source-fn)]
          [(linked)
           (library-setup #f libdirs rt-libs)
           (let* ([missing (do-compile source-fn output-fn libs-visible? #f target-type)]
                  [other-libs (resolve-missing-libs 'linked rt-libs missing)]
                  [hashbang
                   (let ([ip (open-file source-fn O_RDONLY 0 'binary-input)])
                     (on-exit (close-port ip)
                       (let ([end (get-source-offset ip)])
                         (and (> end 0)
                              (begin (file-position ip 0) #t)
                              (get-bytevector-n ip end)))))]
                  [tmp (tmp-filename output-fn)]
                  [ip (open-file output-fn O_RDONLY 0 'binary-input)]
                  [op (open-file tmp (+ O_WRONLY O_CREAT O_APPEND) #o777 'binary-output)])
             (define (cleanup) (close-port ip) (close-port op))
             (match (catch
                     (show-files target-type #f #f rt-libs other-libs source-fn)
                     (put-bytevector op (or hashbang (string->utf8 "#!/usr/bin/env swish\n")))
                     (for-each
                      (lambda (rt-lib)
                        (unless (swish-library-file? rt-lib)
                          (let ([ip (open-file rt-lib O_RDONLY 0 'binary-input)])
                            (on-exit (close-port ip)
                              (copy ip op)))))
                      (append rt-libs other-libs))
                     (copy ip op))
               [#(EXIT ,reason)
                (cleanup)
                (rm-f tmp)
                (raise reason)]
               [,_
                (cleanup)
                (rename-path tmp output-fn)]))]
          [(library) (match "not reached")]))]))])
