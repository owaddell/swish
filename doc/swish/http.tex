% Copyright 2018 Beckman Coulter, Inc.
%
% Permission is hereby granted, free of charge, to any person
% obtaining a copy of this software and associated documentation files
% (the "Software"), to deal in the Software without restriction,
% including without limitation the rights to use, copy, modify, merge,
% publish, distribute, sublicense, and/or sell copies of the Software,
% and to permit persons to whom the Software is furnished to do so,
% subject to the following conditions:
%
% The above copyright notice and this permission notice shall be
% included in all copies or substantial portions of the Software.
%
% THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
% EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
% MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
% NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
% BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
% ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
% CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
% SOFTWARE.

\lstdefinelanguage{json}{
  basicstyle=\upshape\mdseries\frenchspacing\ttfamily,
  columns=flexible,
  string=[s]{"}{"},
  stringstyle=\color{blue},
  comment=[l]{:},
  commentstyle=\color{black},
  escapeinside={|}{|},
  frame=single
}

\chapter {HTTP Interface}\label{chap:http}

\section {Introduction}

The HTTP interface provides a basic implementation of the Hypertext
Transfer Protocol~\cite{RFC7230} and the WebSocket
Protocol~\cite{RFC6455}. The programming interface includes procedures
for the HyperText Markup Language (HTML) version 5~\cite{html5} and
JavaScript Object Notation (JSON)~\cite{RFC7159}.

\section {Theory of Operation}

The HTTP interface provides \code{http:add-file-server} to listen for
connections on a TCP port and serve files from a directory and
\code{http:add-server} to serve content via a user-defined
procedure. These procedures configure the \code{app-sup-spec} to
include one or more web servers in the supervision hierarchy that is
started by \code{app:start}.

Both \code{http:add-file-server} and \code{http:add-server} are
implemented in terms of \code{http:configure-server}, which defines a
supervisor that manages the \emph{listener} gen-server,
\emph{dispatcher} processes, \emph{cache} gen-servers, and
\emph{evaluator} processes. Internally, the listener starts a cache
manager process to support evaluating and serving files. The
dispatcher starts a connection process to manage protocol
details. This structure is illustrated in Figure~\ref{fig:http-tree}.

\begin{figure}
  \center\includegraphics{swish/http-tree.pdf}
  \caption{\label{fig:http-tree}HTTP supervision tree}
\end{figure}

The HTTP supervisor provided via \code{http:configure-server} is
configured one-for-one with up to 10 restarts within 10 seconds.

The \emph{listener} gen-server awaits TCP connections using
\code{listen-tcp} and accepts them using \code{accept-tcp}.  For each
TCP connection, the listener uses its supervisor to spawn and link a
\emph{dispatcher} process that reads each request, calls the \emph{URL
  handler} configured for that listener, and repeats until the
connection closes. The listener closes the associated output port when
the dispatcher exits.

Each \emph{dispacher} process spawns a \emph{connection}
gen-server. The connection is responsible for reading and parsing
requests in a timely manner.  A connection server reads from its input
port until a CR LF occurs.  Well-formed input is converted to a
\code{<request>} tuple. The HTTP request header is then read and
associated with the request.  If the connection takes more than
\code{request-timeout} milliseconds to parse a request, the dispatcher
fires an exception, and the TCP connection is closed.  The dispatcher
logs the specific request, validates that the requested path does not
include ``..'', and invokes the URL handler provided by the listener.

For forms, the URL handler is responsible for checking the request
method and reading form content with \code{http:call-with-form}. Any
unread content as determined by \code{Content-Length} is ignored.

After a request is processed, the current process and connection can
be reused. Unless the \code{Connection} header specifies \code{close},
the system reads another request from the input port after skipping
any unread content from the current request.

\subsection{URL handler and Media Type handler}\label{sec:url-handler}

Using \code{http:add-server} or \code{http:configure-server}
configures a web server to serve content via a URL handler that may be
compiled into the Swish application.

A \emph{URL handler}\index{URL handler} is a procedure that should
return \code{\#t} when it processes a request, and \code{\#f}
otherwise.

To allow future extension without change to application code, the HTTP
interface provides \code{http:url-handler} to define a handler which
exposes the following implicit variables:

\begin{argtbl}
  \argrow{conn}{a connection process}
  \argrow{request}{a \code{<request>} tuple}
  \argrow{header}{a JSON object}
  \argrow{params}{a JSON object}
\end{argtbl}

\code{http:call-url-handler} can be used to invoke a handler, and
\code{http:compose-url-handlers} chains a sequence of handlers
together.

A \emph{media type handler} is a procedure that takes a file extension
as input and returns a media type or \code{\#f}. The default media
type handler always returns \code{\#f}.

\subsection{Default file handling}

Using \code{http:add-file-server} or \code{http:configure-file-server}
configures a web server to serve files from a directory. These
procedures generate a URL handler by calling
\code{http:make-default-file-url-handler}. This handler asks the
\emph{cache manager} gen-server for a cache responsible for the given
directory.

The \emph{cache manager} gen-server maintains the mapping of the
top-level web directory to a \emph{cache} gen-server. If a cache does
not exist for the given path, a new \emph{cache} gen-server is
created.

A \emph{cache} gen-server stores URL handlers and provides a mapping
from file extension to media type. It creates a directory watcher
using \code{watch-directory} to invalidate the cache when anything in
the directory tree changes. It terminates after 5 minutes of
inactivity.

The optional \code{media-type-handler} is configured via
\code{http:make-default-media-type-handler} to match the extension of
\var{filename} case insensitively against an extension in the
\code{mime-types} file of the configured directory. Each line of
\code{mime-types} has the form
\code{("\var{extension}"~.~"\var{Content-Type}")}.

\subsection{Dynamic Pages}\label{sec:dynamic-pages}

A \emph{dynamic page} is any file that is transformed before its
content is sent to the browser. For example, by setting the option
\code{file-transform} to \code{http:enable-dynamic-pages}, a path that
ends in ``.ss'' containing a sequence of definitions followed by a
sequence of expressions is wrapped in a URL handler and evaluated by
the \code{eval} system procedure. The page explicitly sends a response
via \code{http:respond} or \code{http:respond-file}.

In general, a cache gen-server resolves a URL to a file path and
checks its internal state. If a URL handler is unavailable, the
gen-server calls the optional \code{file-transform} procedure passing
the absolute file path.

The \code{file-transform} procedure returns \code{\#f} or a
procedure. When it returns \code{\#f}, the URL is considered static
and is sent directly over the connection using
\code{http:respond-file}.

When it returns a procedure, the cache starts an \emph{evaluator}
process. The evaluator process calls the procedure with the cache's
root directory and the absolute file path. The evaluator procedure
returns \code{\#f} or a URL handler. The cache stores the URL handler.

\subsection{WebSocket Protocol}\label{sec:websocket-protocol}

The WebSocket Protocol enables bidirectional communication and is well
supported by web browsers and software platforms.  The protocol
utilizes message fragmentation and control frame messages.  The
\code{(swish websocket)} library represents a WebSocket connection as
a gen-server referred to as a \emph{websocket}.

The \emph{websocket} gen-server manages message fragmentation, ping
and pong control messages, and sends messages to a separate
process. The following messages are sent:

\antipar\begin{itemize}

\item \code{\#(ws:init \var{ws})}: Indicates that the HTTP protocol
  upgrade to websocket is complete for process \var{ws} and messages
  can be exchanged.

\item \code{\#(ws:message \var{ws} \var{message})}: Indicates that a
  \var{message} bytevector or string was received by process \var{ws}.

\item \code{\#(ws:closed \var{ws} \var{code} \var{reason})}: Indicates
  that the websocket and underlying output port is closed. The cause
  is indicated by the numeric status \var{code}. Status codes 1000 and
  1001 are used to indicate normal exit reasons.  The \var{reason}
  string may be useful for logging and debugging but is not
  necessarily presentable to a user.

\end{itemize}

As a server, a URL handler can call \code{ws:upgrade} in tail position
to switch to the WebSocket Protocol.

A client establishes a connection to a server using \code{ws:connect}
to connect and request usage of the WebSocket Protocol.

\section {Security}

The HTTP interface is written in Scheme, and therefore buffer overrun
exploits cannot be used against the system.

User input should be carefully checked before calling \code{eval} or
invoking a database query.

A URL which directs the system away from a cache's root path using
``..'' could allow access to system files. Therefore, the dispatcher
explicitly rejects relative paths.

The HTTP interface limits incoming data to protect against large
memory allocation that may crash the application.

The HTTP interface allows individual form URL handlers to specify
incoming data and file upload limits to protect against large memory
allocation and running out of disk space.

\section {Programming Interface}

\begin{tupledef}{<request>}
  \argrow{host}{a string}
  \argrow{method}{a symbol}
  \argrow{path}{a decoded string}
  \argrow{original-path}{same as \var{path}}
  \argrow{header}{a decoded JSON object}
  \argrow{params}{a decoded JSON object}
\end{tupledef}

The \var{original-path} is used internally when redirecting the
browser to a new location. If user code copies the \code{<request>}
tuple, it should not modify \var{original-path}.

\defineentry{http:configure-server}
\defineentry{http:options}
\begin{procedure}
  \code{(http:configure-server \var{name} \var{port} \var{url-handler} \opt{\var{options}})}
\end{procedure}
\returns{} a list of child specifications (see page~\pageref{page:child-spec})

\begin{argtbl}
  \argrow{name}{a symbol for the listener gen-server or \code{\#f} for
    an anonymous server}
  \argrow{port}{a fixnum $0 \le port \le 65535$}
  \argrow{url-handler}{a procedure}
  \argrow{options}{see below}
\end{argtbl}

The \code{http:configure-server} procedure returns a list of
supervisor child specifications that define an HTTP server.

The specification defines a supervisor configured as one-for-one with
up to 10 restarts every 10 seconds. The supervisor starts a listener
gen-server. This supervisor is used to create dispatcher, cache,
and evaluator processes.

The listener is a gen-server registered as \var{name}. It accepts
connections on the given TCP \var{port} and processes them with
\var{url-handler}.

The \var{options} can be defined using \code{(http:options
  (\var{option} \var{value}) \etc)}. The following options may be
used:

\begin{tabular}{lrp{.5\textwidth}}
  option & default & description \\ \hline

  \code{request-limit} & 8,192 & a positive fixnum; the maximum length
  in bytes of the first line of an HTTP request \\

  \code{request-timeout} & 30,000 & a positive fixnum; the maximum
  number of milliseconds to wait to receive an HTTP request after
  initial connection \\

  \code{response-timeout} & 60,000 & a positive fixnum; the maximum
  number of milliseconds to allow the server to send a response \\

  \code{header-limit} & 1,048,576 & a positive fixnum; the maximum
  length in bytes of the HTTP request headers \\

  \code{media-type-handler} & \code{(lambda (ext) \#f)} & a procedure;
  given a file extension returns the media type of the file or
  \code{\#f} \\

  \code{file-search-extensions} & \code{'(".html")} & a list of
  strings; a cache process uses the list to disambiguate URL paths to
  file system paths. \\

  \code{file-transform} & \code{(lambda (path) \#f)} & a procedure; a
  cache process calls this procedure with a file path and expects an
  evaluator procedure or \code{\#f} (see \S\ref{sec:dynamic-pages}) \\

  \code{validate-path} & \code{http:valid-path?} & a predicate;
  the server raises an exception if the \code{<request>} \var{path}
  does not satisfy this prediate. \\

\end{tabular}

\defineentry{http:add-server}
\begin{syntax}
  \code{(http:add-server \var{arg} \etc)}
\end{syntax}

The \code{http:add-server} macro expands to code that appends the
result of \code{(http:configure-server \var{arg} \etc)} to the
\code{app-sup-spec} parameter.

\defineentry{http:configure-file-server}
\begin{procedure}
  \code{(http:configure-file-server \var{name} \var{port} \var{dir} \opt{\var{options}})}
\end{procedure}
\returns{} a list of child specifications (see page~\pageref{page:child-spec})

The \code{http:configure-file-server} procedure defines an HTTP server
that provides content from the file-system rooted at \var{dir}.

The \code{http:configure-file-server} procedure calls
\code{http:configure-server} with
\code{(http:make-default-file-url-handler \var{dir})} as the URL
handler. If the \code{media-type-handler} option is not specified, it
defaults to one constructed via
\code{(http:make-default-media-type-handler \var{dir})}.

\defineentry{http:add-file-server}
\begin{syntax}
  \code{(http:add-file-server \var{arg} \etc)}
\end{syntax}

The \code{http:add-file-server} macro expands to code that appends the
result of \code{(http:configure-file-server \var{arg} \etc)} to the
\code{app-sup-spec} parameter.

\defineentry{http:make-default-file-url-handler}
\begin{procedure}
  \code{(http:make-default-file-url-handler \var{dir})}
\end{procedure}
\returns{} a URL handler

The \code{http:make-default-file-url-handler} defines a URL handler
that retrieves the cache responsible for the directory \var{dir}. It
then looks up a URL handler from the cache for the given request. If
found, it calls the handler and flushes the output port. Otherwise, it
returns \code{\#f}.

\defineentry{http:make-default-media-type-handler}
\begin{procedure}
  \code{(http:make-default-media-type-handler \var{dir})}
\end{procedure}
\returns{} a media type handler

The \code{http:make-default-media-type-handler} defines a media type
handler that retrieves the cache responsible for the directory
\var{dir}. It then requests the media type for the given file
extension. If found, the type is returned. Otherwise, it returns
\code{\#f}.

\defineentry{http:url-handler}
\begin{syntax}
  \code{(http:url-handler \var{body\(\sb{1}\)} \var{body\(\sb{2}\)} \etc)}
\end{syntax}

The \code{http:url-handler} macro defines a URL handler procedure
described in Section~\ref{sec:url-handler}.

\defineentry{http:call-url-handler}
\begin{syntax}
  \code{(http:call-url-handler \var{handler})}
\end{syntax}

The \code{http:call-url-handler} macro invokes a URL handler,
implicitly capturing variables in scope as described in
Section~\ref{sec:url-handler}.

\defineentry{http:compose-url-handlers}
\begin{procedure}
  \code{(http:compose-url-handlers \var{handlers})}
\end{procedure}
\returns{} a URL handler

The \code{http:compose-url-handlers} procedure defines a URL handler
that takes a list of \emph{handlers} and invokes each handler, in
order, until one returns \code{\#t}. Otherwise, it returns \code{\#f}.

If a URL handler returns \code{\#f} but sends output to the
output-port, exception \code{http-side-effecting-handler} is raised.

\defineentry{http:get-port-number}
\begin{procedure}
  \code{(http:get-port-number \var{listener})}
\end{procedure}
\returns{} the listener gen-server TCP port number

The \code{http:get-port-number} procedure calls \code{(gen-server:call
  \var{listener} 'get-port-number)}. If the listener's port was
configured to be zero, the operating system will choose an available
port number.  \code{http:get-port-number} uses
\code{listener-port-number} to retrieve the actual port number that
the server is listening on.

\defineentry{http:find-header}
\begin{procedure}
  \code{(http:find-header \var{name} \var{header})}
\end{procedure}
\returns{} a string \alt{} \code{\#f}

The \code{http:find-header} procedure returns the value associated
with \var{name} in JSON object \var{header} if present and \code{\#f}
otherwise.  If \var{name} is a symbol, the lookup uses \code{eq?}.  If
\var{name} is a string, it is first mapped to a lower-case symbol
before performing the lookup.  Otherwise, the exception
\code{\#(bad-arg http:find-header \var{name})} is raised.

\defineentry{http:get-header}
\begin{procedure}
  \code{(http:get-header \var{name} \var{header})}
\end{procedure}
\returns{} a string

The \code{http:get-header} procedure returns the value associated with
\var{name} in JSON object \var{header} if present and raises exception
\code{\#(http-invalid-header \var{name})} otherwise.  If \var{name} is
a symbol, the lookup uses \code{eq?}.  If \var{name} is a string, it
is first mapped to a lower-case symbol before performing the lookup.
Otherwise, the exception \code{\#(bad-arg http:get-header \var{name})}
is raised.

\defineentry{http:get-content-length}
\begin{procedure}
  \code{(http:get-content-length \var{header})}
\end{procedure}
\returns{} an unsigned integer \alt{} \code{\#f}

The \code{http:get-content-length} procedure returns the unsigned
integer value associated with \code{content-length} in JSON object
\var{header} if present and \code{\#f} otherwise. It raises exception
\code{\#(http-invalid-content-length \var{value})} if the \var{value}
string does not represent an unsigned integer.

\defineentry{http:find-param}
\begin{procedure}
  \code{(http:find-param \var{name} \var{params})}
\end{procedure}
\returns{} a string \alt{} \code{\#f}

The \code{http:find-param} procedure returns the value associated with
\var{name} in JSON object \var{params} if present and \code{\#f}
otherwise.  If \var{name} is a symbol, the lookup uses \code{eq?}.  If
\var{name} is a string, it is converted to a symbol before performing
the lookup.  Otherwise, the exception \code{\#(bad-arg http:find-param
  \var{name})} is raised.

\defineentry{http:get-param}
\begin{procedure}
  \code{(http:get-param \var{name} \var{params})}
\end{procedure}
\returns{} a string

The \code{http:get-param} procedure returns the value associated with
\var{name} in JSON object \var{params} if present and raises exception
\code{\#(http-invalid-param \var{name})} otherwise.  If \var{name} is
a symbol, the lookup uses \code{eq?}.  If \var{name} is a string, it
is converted to a symbol before performing the lookup.  Otherwise, the
exception \code{\#(bad-arg http:get-param \var{name})} is raised.

\defineentry{http:read-header}
\begin{procedure}
  \code{(http:read-header \var{ip} \var{limit})}
\end{procedure}
\returns{} a JSON object

The \code{http:read-header} procedure reads from the binary input port
\var{ip} until it reads a blank line.  It creates a JSON object where
the key is a symbol formed from the down-cased characters before the
first colon and the value is a string formed from the characters that
remain after skipping white space.  Duplicate message-header fields
result in a single entry where the value is a comma-separated list.

Reading beyond \var{limit} raises exception
\code{http-input-limit-exceeded}.

Failure to find a colon on any given line raises exception
\code{http-invalid-header}.

\defineentry{http:read-status}
\begin{procedure}
  \code{(http:read-status \var{ip} \var{limit})}
\end{procedure}
\returns{} number \alt{} \code{\#f}

The \code{http:read-status} procedure reads the HTTP response status
line from the binary input port \var{ip} and returns the status code
as a number if well formed and \code{\#f} otherwise. Reading beyond
\var{limit} raises exception \code{http-input-limit-exceeded}.

\defineentry{http:write-status}
\begin{procedure}
  \code{(http:write-status \var{op} \var{status})}
\end{procedure}
\returns{} unspecified

The \code{http:write-status} procedure writes the HTTP response
status line to the binary output port \var{op}.

Unless \var{status} is a fixnum and $100 \leq \var{status} \leq 599$, the
exception \code{\#(bad-arg http:write-status \var{status})} is
raised.

According to HTTP~\cite{RFC7230} the status line includes a
human-readable reason phrase. The grammar shows that it can in fact be
zero characters long; therefore, the reason phrase is not included in
this implementation.

\defineentry{http:write-header}
\begin{procedure}
  \code{(http:write-header \var{op} \var{header-alist})}
\end{procedure}
\returns{} unspecified

The \code{http:write-header} procedure writes the HTTP
\var{header-alist} and trailing CR LF to the binary output port
\var{op}.

\var{header-alist} is an association list whose keys and values are
strings. If any of its keys are not strings, exception
\code{\#(bad-arg http:write-header \var{header-alist})} is raised.

\defineentry{http:respond}
\begin{procedure}
  \code{(http:respond \var{conn} \var{status} \var{header-alist} \opt{\var{content} \opt{\var{timeout}}})}
\end{procedure}
\returns{} \code{\#t}

The \code{http:respond} procedure writes the HTTP \var{status} and
\var{header-alist} to the connection \var{conn} using
\code{http:write-status} and \code{http:write-header}, adding
\code{Content-Length} to \var{header-alist} in situations described
below. When \code{Cache-Control} is not present in \var{header-alist},
it is added with value \code{no-cache}. When \var{content} is a
bytevector, it is written. Then the output port is flushed.

The default value of \var{content} is \code{\#f}, which specifies that
the \code{Content-Length} header is not added. When \var{status} is
100--199, 204, or 304, the \code{Content-Length} header is not added,
and if \var{content} is a bytevector, it must be empty. Otherwise, the
\code{Content-Length} header is added with the length of
\var{content}.

The default value of \var{timeout} is \code{(response-timeout)}.

\defineentry{http:respond-file}
\begin{procedure}
  \code{(http:respond-file \var{conn} \var{status} \var{header-alist} \var{filename} \opt{\var{timeout}})}
\end{procedure}
\returns{} \code{\#t}

The \code{http:respond-file} procedure writes the HTTP \var{status}
and \var{header-alist} to the connection \var{conn} using
\code{http:write-status} and \code{http:write-header}, adding
\code{Content-Length} to \var{header-alist}.  The \code{Cache-Control}
header is added, if it is not already present, with value
\code{max-age=3600}.  The \code{Content-Type} header is added, if it
is not already present, by calling the \code{media-type-handler}.  The
content of the file is streamed to the output port so that the file
does not need to be loaded into memory. The output port is flushed.

The default value of \var{timeout} is \code{(response-timeout)}.

\defineentry{http:call-with-form}
\begin{procedure}
  \code{(http:call-with-form \var{conn} \var{header}
    \var{content-limit} \var{file-limit} \var{files} \var{f}
    \opt{\var{timeout}})}
\end{procedure}
\returns{} see below

The \code{http:call-with-form} procedure checks JSON object
\var{header} for a \code{content-type} of \code{multipart/form-data}
or \code{application/x-www-form-urlencoded}. It parses form name/value
pairs into a JSON object.  After parsing the form data, the function
\var{f} is called with the JSON object. After \var{f} returns, all
uploaded files are deleted, and the return value is passed to the
caller.

Because \code{http:call-with-form} is used inside a URL handler after
the \code{<http-request>} event has been fired, the specific form data
is not logged. Applications should consider the sensitivity of
submitted data before logging.

When files are sent and the form variable name appears in the
\var{files} list, the file is stored in \code{(tmp-dir)}, and the JSON
value is a JSON object with \code{type="file"} and
\code{filename=\var{filename}}.

For example, a form sending the variables \code{name}, \code{rank},
and \code{image} might look like:

\begin{lstlisting}[language=json,frame=none]
{
  "name": "Steve R",
  "rank": "Captain",
  "image":
  {
    "type": "file",
    "filename": |\var{filename}|
  }
}
\end{lstlisting}

Name/value pairs count against \var{content-limit} while file data
counts against \var{file-limit}. An exception is raised when either
limit is exceeded.

The default value of \var{timeout} is \code{(request-timeout)}.

\defineentry{http:call-with-ports}
\begin{procedure}
  \code{(http:call-with-ports \var{conn} \var{f} \opt{\var{timeout}})}
\end{procedure}
\returns {} see below

The \code{http:call-with-ports} procedure ignores any current
connection state and calls \var{f} in the connection process with the
connection's input and output ports.  Running \var{f} in the
connection process allows the caller to timeout when input is
unavailable. The return value of \var{f} is returned to the caller.

The default value of \var{timeout} is 5000 milliseconds.

\defineentry{http:switch-protocol}
\begin{procedure}
  \code{(http:switch-protocol \var{proc})}
\end{procedure}
\returns {} see below

When used in a URL handler, \code{http:switch-protocol} returns a
special value to control the dispatcher loop. The dispatcher detaches
from the connection process and calls \var{proc} with the input and
output ports.

\defineentry{http:percent-encode}
\begin{procedure}
  \code{(http:percent-encode \var{s})}
\end{procedure}
\returns{} an encoded string

The \code{http:percent-encode} procedure writes the characters
\code{A}--\code{Z}, \code{a}--\code{z},
\code{0}--\code{9}, hyphen, underscore, period, and
\code{\~}. Other characters are converted to a \code{\%} prefix
and two digit hexadecimal representation.

\defineentry{http:enable-dynamic-pages}
\begin{procedure}
  \code{(http:enable-dynamic-pages \var{path})}
\end{procedure}
\returns{} a procedure \alt{} \code{\#f}

If the file extension of \var{path} is ``.ss'', the
\code{http:enable-dynamic-pages} procedure returns the
\code{http:eval-dynamic-page} procedure. Otherwise, it returns
\code{\#f}.

\defineentry{http:eval-dynamic-page}
\begin{procedure}
  \code{(http:eval-dynamic-page \var{root-dir} \var{abs-path})}
\end{procedure}
\returns{} a URL handler

The \code{http:eval-dynamic-page} procedure wraps a
\code{http:url-handler} around the contents of a file, extends the
syntax with the constructs described in
Section~\ref{sec:dynamic-page-constructs}, and calls the \code{eval}
system procedure.

\defineentry{http:valid-path?}
\begin{procedure}
  \code{(http:vavlid-path? \var{path})}
\end{procedure}
\returns{} boolean

The \code{http:valid-path?} procedure checks that the \var{path} from a \code{<request>} is a string that begins with \code{/} and contains no \code{".."} path elements when decomposed as a filesystem path.
On Windows this procedure treats both \code{/} and \code{\textbackslash}
as path separators since some filesystem operations accept both.

\subsection {Dynamic Page Constructs}\label{sec:dynamic-page-constructs}

A dynamic page exposes the same implicit variables as a URL handler
described in Section~\ref{sec:url-handler} as well as the following
additional syntax.

\defineentry{find-param}
\begin{syntax}
  \code{(find-param \var{key})}
\end{syntax}\antipar
\implementation{The \code{find-param} macro expands to
  \code{(http:find-param \var{key} \var{params})}.}

\defineentry{get-param}
\begin{syntax}
  \code{(get-param \var{key})}
\end{syntax}\antipar
\implementation{The \code{get-param} macro expands to
  \code{(http:get-param \var{key} \var{params})}.}

\defineentry{http:include}
\begin{syntax}
  \code{(http:include "\var{filename}")}
\end{syntax}\antipar

The \code{http:include} construct includes the definitions from
\var{filename}, a path relative to the root path of the cache if
\var{filename} begins with a forward slash, else relative to the
directory of the current file.

\implementation{The \code{http:include} macro calls
  \code{read-file} and \code{read-bytevector} to retrieve a list
  of expressions that are spliced in at the same scope as the use of
  \code{http:include}. The splicing is done with \code{let-syntax}
  so that any nested \code{http:include} expressions are processed
  relative to the directory of \var{filename}.}

\subsection {WebSocket Protocol}

\defineentry{ws:upgrade}
\defineentry{ws:options}
\begin{procedure}
  \code{(ws:upgrade \var{conn} \var{request} \var{process} \opt{\var{options}})}
\end{procedure}
\returns{} see below

The \code{ws:upgrade} procedure checks the header of the \var{request}
tuple and upgrades the calling process to a gen-server that speaks the
WebSocket protocol. The connection \var{conn} is used during the
opening handshake to report errors. As it runs, the gen-server sends
the messages defined in Section~\ref{sec:websocket-protocol} to the
given \var{process}. It raises an exception upon termination (see
\code{gen-server:enter-loop}).

The \var{options} are defined with \code{(ws:options (\var{option}
  \var{value}) \etc)}. The following options may be used:

\begin{tabular}{lrp{.5\textwidth}}
  option & default & description \\ \hline

  \code{fragmentation-size} & 1,048,576 & a positive fixnum or
  \code{\#f} to disable; the maximum length in bytes of a single
  message payload \\

  \code{maximum-message-size} & 16,777,216 & a positive fixnum; the
  maximum length in bytes of the total payload for a single message
  that can be read from input \\

  \code{ping-frequency} & 30,000 & a positive fixnum; the maximum
  number of milliseconds since last receiving a message before issuing
  a ping request \\

  \code{pong-timeout} & 5,000 & a positive fixnum; the maximum number
  of milliseconds to wait for a reply to a ping before failing
\end{tabular}

\defineentry{ws:connect}
\begin{procedure}
  \code{(ws:connect \var{hostname} \var{port} \var{request} \var{process} \opt{\var{options}})}
\end{procedure}
\returns{} a websocket gen-server process

The \code{ws:connect} procedure initiates a TCP connection to
\var{hostname} on the given \var{port} number and issues an upgrade
for the \var{request} uniform resource identifier string. It then
spawns and returns a gen-server process that sends the messages
defined in Section~\ref{sec:websocket-protocol} to the given
\var{process}.

The \var{options} are the same as defined for \code{ws:upgrade}.

\defineentry{ws:send}
\defineentry{ws:send"!} % use " to escape the ! for index entry
\begin{procedure}
  \code{(ws:send \var{server} \var{message})}\\
  \code{(ws:send! \var{server} \var{message})}
\end{procedure}
\returns{} \code{ok}

The \code{ws:send} procedure uses \code{gen-server:cast} to transmit
the bytevector or string \var{message} to the websocket process or
registered name \var{server}.
The \code{ws:send!} procedure is like \code{ws:send} except that it does
not copy bytevector messages, but may instead destructively update them
to apply a mask for transmission.

\defineentry{ws:close}
\begin{procedure}
  \code{(ws:close \var{server})}
\end{procedure}
\returns{} \code{ok}

The \code{ws:close} procedure uses \code{gen-server:cast} to close the
websocket process or registered name \var{server}.

\subsection {HyperText Markup Language}

\defineentry{html:encode}
\begin{procedure}
  \code{(html:encode \var{s})} \\
  \code{(html:encode \var{op} \var{s})}\strut
\end{procedure}
\returns{} see below

The \code{html:encode} procedure converts special character entities
in string \var{s}.

\begin{tabular}{ll}
  input & output \\ \hline
  \code{"} & \code{\&quot;} \\
  \code{\&} & \code{\&amp;} \\
  \code{\textless} & \code{\&lt;} \\
  \code{\textgreater} & \code{\&gt;} \\
  \hline
\end{tabular}

The single argument form of \code{html:encode} returns an encoded
string.

The two argument form of \code{html:encode} sends the encoded string
to the textual output port \var{op}.

\defineentry{html->string}
\begin{procedure}
  \code{(html->string \var{x})} \\
  \code{(html->string \var{op} \var{x})}\strut
\end{procedure}
\returns{} see below

The \code{html->string} procedure transforms an object into
HTML. The transformation, $H$, is described below:

\begin{tabular}{ll}
  \var{x} & $H(\var{x})$\\ \hline

  \code{()} & nothing\\
  \code{\#!void} & nothing\\
  \code{\var{string}} & $E(\var{string})$\\
  \code{\var{number}} & \var{number}\\
  \code{(begin \var{pattern} \etc)} & $H(\var{pattern})$\etc\\
  \code{(cdata \var{string} \etc)} &
  \code{[!CDATA[\var{string}$\etc$]]}\\
  \code{(html5 \opt{(@ \var{attr} \etc)} \var{pattern} \etc)} &
  \code{<!DOCTYPE html><html $A(\var{attr})$ $\etc$>$H(\var{pattern})\etc$</html>}\\
  \code{(raw \var{string} \etc)} & \var{string}$\etc$\\
  \code{(script \opt{(@ \var{attr} \etc)} \var{string} \etc)} &
  \code{<script $A(\var{attr})$ $\etc$>\var{string}$\etc$</script>}\\
  \code{(style \opt{(@ \var{attr} \etc)} \var{string} \etc)} &
  \code{<style $A(\var{attr})$ $\etc$>\var{string}$\etc$</style>}\\
  \code{(\var{tag} \opt{(@ \var{attr} \etc)} \var{pattern} \etc)} &
  \code{<\var{tag} $A(\var{attr})$ $\etc$>$H(\var{pattern})\etc$</\var{tag}>}\\
  \code{(\var{void-tag} \opt{(@ \var{attr} \etc)})} &
  \code{<\var{void-tag} $A(\var{attr})$ $\etc$>}\\

  \hline
\end{tabular}

$E$ denotes the \code{html:encode} function.

For the \code{html5} tag, if there is no \var{attr} with \code{lang} as its key,
then $H$ acts as if the \var{attr} \code{(lang "en")} were specified.

A \var{void-tag} is one of \code{area}, \code{base}, \code{br},
\code{col}, \code{embed}, \code{hr}, \code{img},
\code{input}, \code{keygen}, \code{link}, \code{menuitem},
\code{meta}, \code{param}, \code{source}, \code{track}, or
\code{wbr}. A \var{tag} is any other symbol.

The attribute transformation, $A$, is described below, where \var{key}
is a symbol:

\begin{tabular}{ll}
  \var{attr} & $A(\var{attr})$\\ \hline

  \code{\#!void} & nothing\\
  \code{(\var{key})} & \var{key}\\
  \code{(\var{key} \var{string})} & \code{\var{key}="$E(\var{string})$"}\\
  \code{(\var{key} \var{number})} & \code{\var{key}="\var{number}"}\\

  \hline
\end{tabular}

The single argument form of \code{html->string} returns an encoded
HTML string.

The two argument form of \code{html->string} sends the encoded HTML
string to the textual output port \var{op}.

Input that does not match the specification causes a
\code{\#(bad-arg html->string \var{x})} exception to be raised.

\defineentry{html->bytevector}
\begin{procedure}
  \code{(html->bytevector \var{x})}
\end{procedure}
\returns{} a bytevector

The \code{html->bytevector} procedure calls \code{html->string} on
\var{x} using a bytevector output port transcoded using
\code{(make-utf8-transcoder)} and returns the resulting bytevector.

\subsection {JavaScript Object Notation}

This implementation translates JavaScript types into the following
Scheme types:

\begin{tabular}{ll}
  JavaScript & Scheme \\ \hline

  \code{true} & \code{\#t} \\
  \code{false} & \code{\#f} \\
  \code{null} & \code{\#\textbackslash nul} \\
  \var{string} & \var{string} \\
  \var{number} & \var{number} \\
  \var{array} & \var{list} \\
  \var{object} & hashtable mapping symbols to values \\

  \hline
\end{tabular}

This implementation does not range check values to ensure that a
JavaScript implementation can interpret the data.

\defineentry{json:extend-object}
\begin{syntax}
  \code{(json:extend-object \var{ht} [\var{key} \var{value}] \etc)}
\end{syntax}

The \code{json:extend-object} construct adds the \var{key} /
\var{value} pairs to the hashtable \var{ht} using
\code{hashtable-set!}. Each \var{key} is a literal identifier
or an unquoted expression \code{,\var{e}} that evaluates to a
symbol. The resulting expression returns \var{ht}.

\defineentry{json:make-object}
\begin{syntax}
  \code{(json:make-object [\var{key} \var{value}] \etc)}
\end{syntax}

The \code{json:make-object} construct expands into a call to
\code{json:extend-object} with a new hashtable.

\defineentry{json:object?}
\begin{procedure}
  \code{(json:object? \var{x})}
\end{procedure}
\returns{} a boolean

The \code{json:object?} procedure determines whether or not the datum
\var{x} is an object created by \code{json:make-object}.

\defineentry{json:cells}
\begin{procedure}
  \code{(json:cells \var{ht})}
\end{procedure}
\returns{} a vector

The \code{json:cells} procedure returns a vector containing the
cells of the underlying hashtable.

\defineentry{json:size}
\begin{procedure}
  \code{(json:size \var{ht})}
\end{procedure}
\returns{} an integer

The \code{json:size} procedure returns the number of cells
in the underlying hashtable.

\defineentry{json:delete"!}
\begin{procedure}
  \code{(json:delete! \var{ht} \var{path})}
\end{procedure}
\returns{} unspecified

The \code{json:delete!} procedure expects \var{path} to be a symbol or
a non-empty list of symbols.
If \var{path} is a symbol, then \code{json:delete!} is equivalent
to \code{hashtable-delete!}.
Otherwise, \code{json:delete!} follows \var{path} as it descends into
the nested hashtable \var{ht}, treating each element as a key into
the hashtable reached by traversing the preceding elements.
When \code{json:delete!} reaches the final key in \var{path},
it calls \code{hashtable-delete!} to remove the association for
that key in the hashtable reached at that point.
If any key along the way does not map to a hashtable,
\code{json:delete!} has no effect.

\defineentry{json:ref}
\begin{procedure}
  \code{(json:ref \var{ht} \var{path} \var{default})}
\end{procedure}
\returns{} the value found by traversing \var{path} in \var{ht},
\var{default} if none

The \code{json:ref} procedure expects \var{path} to be a symbol or
a non-empty list of symbols.
If \var{path} is a symbol, then \code{json:ref} is equivalent
to \code{hashtable-ref}.
Otherwise, \code{json:ref} follows \var{path} as it descends into
the nested hashtable \var{ht}, treating each element as a key into
the hashtable reached by traversing the preceding elements.
When \code{json:ref} reaches the final key in \var{path},
it calls \code{hashtable-ref} to retrieve the value of that key
in the hashtable reached at that point.
If any key along the way does not map to a hashtable,
or if the final hashtable does not contain the final key,
\code{json:ref} returns \var{default}.

\defineentry{json:set"!}
\begin{procedure}
  \code{(json:set! \var{ht} \var{path} \var{value})}
\end{procedure}
\returns{} unspecified

The \code{json:set!} procedure expects \var{path} to be a symbol or
a non-empty list of symbols.
If \var{path} is a symbol, then \code{json:set!} is equivalent
to \code{hashtable-set!}.
Otherwise, \code{json:set!} follows \var{path} as it descends into
the nested hashtable \var{ht}, treating each element as a key into
the hashtable reached by traversing the preceding elements.
When \code{json:set!} reaches the final key in \var{path},
it calls \code{hashtable-set!} to set that key in the
hashtable reached at that point.
If any key along the way does not map to a hashtable,
\code{json:set!} installs an empty hashtable at that key
before proceding.
If \var{path} is malformed at some point, \code{json:set!} may
still mutate hashtables along the valid portion of the path
before reporting an error.

\defineentry{json:update"!}
\begin{procedure}
  \code{(json:update! \var{ht} \var{path} \var{procedure} \var{default})}
\end{procedure}
\returns{} unspecified

The \code{json:update!} procedure expects \var{path} to be a symbol or
a non-empty list of symbols.
If \var{path} is a symbol, then \code{json:update!} is equivalent
to \code{hashtable-update!}.
Otherwise, \code{json:update!} follows \var{path} as it descends into
the nested hashtable \var{ht}, treating each element as a key into
the hashtable reached by traversing the preceding elements.
When \code{json:update!} reaches the final key in \var{path},
it calls \code{hashtable-update!} to update that key in the
hashtable reached at that point.
If any key along the way does not map to a hashtable,
\code{json:update!} installs an empty hashtable at that key
before proceding.
If \var{path} is malformed at some point, \code{json:update!} may
still mutate hashtables along the valid portion of the path
before reporting an error.

\defineentry{json:read}
\begin{procedure}
  \code{(json:read \var{ip} \opt{\var{custom-inflate}})}
\end{procedure}
\returns{} a Scheme object or the eof object

The \code{json:read} procedure reads characters from the textual
input port \var{ip} and returns an appropriate Scheme object.
When \code{json:read} encounters a JSON object, it builds
the corresponding hashtable and calls \var{custom-inflate}
to perform application-specific conversion.
By default, \var{custom-inflate} is the identity function.

The following exceptions may be raised:
\begin{itemize}
\item \code{invalid-surrogate-pair}
\item \code{unexpected-eof}
\item \code{\#(unexpected-input \var{data} \var{input-position})}
\end{itemize}

\defineentry{json:write}
\begin{procedure}
  \code{(json:write \var{op} \var{x} \opt{\var{indent}} \opt{\var{custom-write}})}
\end{procedure}
\returns{} unspecified

The \code{json:write} procedure writes the object \var{x} to the
textual output port \var{op} in JSON format. By default, \code{json:write}
sorts the keys of JSON objects using \code{string<?}, after converting
the symbolic keys to strings.
This sort order provides stable output.
The \code{json:key<?} parameter may be used to alter or disable key sorting.
Scheme fixnums, bignums, and finite flonums may
be used as numbers.

When \var{indent} is a non-negative fixnum, the output is more
readable by a human. List items and key/value pairs are indented on
individual lines by the specified number of spaces. When \var{indent}
is 0, a newline is added to the end of the output. The default indent
of \code{\#f} produces compact output.

The optional \var{custom-write} procedure may intervene to handle
lists and hashtables differently or to handle objects that have no
direct JSON counterpart.  If \var{custom-write} does not handle a
given object, it should return false to let \code{json:write} proceed
normally.  The \var{custom-write} procedure is called with four
arguments: the textual output port \var{op}, the Scheme object
\var{x}, the current \var{indent} level, and a writer procedure
\var{wr} that should be used to write the values of arbitrary Scheme
objects.  The \var{wr} procedure is equivalent to
\code{(lambda (\var{op} \var{x} \var{indent}) (json:write \var{op} \var{x} \var{indent} \var{custom-write}))}.

The default value of \var{custom-write} is the value stored in the
\code{json:custom-write} process-parameter.

If an object cannot be formatted, \code{\#(invalid-datum \var{x})}
is raised.

\defineentry{json:write-object}
\begin{syntax}
  \code{(json:write-object \var{op} \var{indent} \var{wr} [\var{key} \var{value}] \etc)}
\end{syntax}
\returns{} \code{\#t}

Given a textual output port \var{op}, an \var{indent} level, and a
writer procedure \var{wr}, the \code{json:write-object} construct
writes a JSON object with the given \var{key} / \var{value} pairs to
\var{op}. By default, \code{json:write-object} sorts the keys using
\code{string<?} on the string values of the symbols.
To alter or disable key sorting, see the \code{json:key<?} parameter.

Each \var{key} must be a distinct symbol.  The \var{wr}
procedure takes \var{op}, an object \var{x}, and an \var{indent} level
just like the \var{wr} procedure that is passed to \code{json:write}'s
\var{custom-write} procedure.

The following are equivalent, provided the keys are symbols and \code{json:key<?} has its default value.

\antipar\begin{alltt}
(begin (json:write \var{op} (json:make-object [\var{key} \var{value}] \etc) \var{indent}) \#t)
(json:write-object \var{op} \var{indent} json:write [\var{key} \var{value}] \etc)\end{alltt}\antipar

The latter trades code size and compile time for run-time efficiency.
At compile time, \code{json:write-object} sorts the keys and
preformats the strings that will separate values.

\defineentry{json:pretty}
\begin{procedure}
  \code{(json:pretty \var{x} \opt{\var{op}})}
\end{procedure}
\returns{} unspecified

The \code{json:pretty} procedure formats an object \var{x} to the
optional textual output port \var{op} in a human-readable form. The
object is indented and keys are sorted using
\code{natural-string-ci<?}. The default value of \var{op} is
\code{(current-output-port)}.

Calling \code{(json:pretty x)} is roughly equivalent to the following:
\antipar\codebegin
(parameterize ([json:key<? natural-string-ci<?])
  (json:write (current-output-port) x 0))
\codeend

\defineentry{json:custom-write}
\begin{parameter}
  \code{json:custom-write}
\end{parameter}
\returns{} a procedure or \code{\#f}

The \code{json:custom-write} process-parameter determines the default
\var{custom-write} argument for \code{json:write} and the other JSON
output procedures.

\defineentry{json:key<?}
\begin{parameter}
  \code{json:key<?}
\end{parameter}
\returns{} a boolean or a predicate for comparing two strings

The \code{json:key<?} parameter determines whether and how
\code{json:pretty}, \code{json:write}, and \code{json:write-object} sort keys
when writing JSON objects.
If set to \code{\#f}, keys are not sorted and the output order is arbitrary.
Otherwise, the output is sorted by obtaining a string for each key
via \code{symbol->string} and comparing those strings using the predicate
specified by \code{json:key<?}.
If \code{json:key<?} is set to \code{\#t}, which is the default,
then \code{json:pretty} sorts with \code{natural-string-ci<?}
while \code{json:write} and \code{json:write-object} sort with
\code{string<?}.
To affect the output of \code{json:write-object}, \code{json:key<?} must
be set to the desired value at expand time.

\defineentry{json:object->bytevector}
\begin{procedure}
  \code{(json:object->bytevector \var{x} \opt{\var{indent}} \opt{\var{custom-write}})}
\end{procedure}
\returns{} a bytevector

The \code{json:object->bytevector} procedure calls \code{json:write}
on \var{x} with the optional \var{indent} and \var{custom-write}, if
any, using a bytevector output port transcoded using
\code{(make-utf8-transcoder)} and returns the resulting bytevector.

\defineentry{json:bytevector->object}
\begin{procedure}
  \code{(json:bytevector->object \var{x} \opt{\var{custom-inflate}})}
\end{procedure}
\returns{} a Scheme object

The \code{json:bytevector->object} procedure creates a bytevector input port
on \var{x}, calls \code{json:read} with the optional \var{custom-inflate},
if any, and returns the resulting Scheme object after making sure the rest
of the bytevector is only whitespace.

\defineentry{json:object->string}
\begin{procedure}
  \code{(json:object->string \var{x} \opt{\var{indent}} \opt{\var{custom-write}})}
\end{procedure}
\returns{} a JSON formatted string

The \code{json:object->string} procedure creates a string output port,
calls \code{json:write} on \var{x} with the optional \var{indent} and
\var{custom-write}, if any, and returns the resulting string.

\defineentry{json:string->object}
\begin{procedure}
  \code{(json:string->object \var{x} \opt{\var{custom-inflate}})}
\end{procedure}
\returns{} a Scheme object

The \code{json:string->object} procedure creates a string input port
on \var{x}, calls \code{json:read} with the optional \var{custom-inflate},
if any, and returns the resulting Scheme object after making sure the rest
of the string is only whitespace.

\defineentry{json:write-structural-char}
\begin{procedure}
  \code{(json:write-structural-char \var{x} \var{indent} \var{op})}
\end{procedure}
\returns{} the new indent level

The \code{json:write-structural-char} procedure writes the character
\var{x} at an appropriate \var{indent} level to the textual output
port \var{op}. The character should be one of the following JSON
structural characters: \code{[ ] \{ \} : ,}

This procedure is intended for use within custom writers passed in to
\code{json:write} and, for performance, it does not check its input arguments.

\section {Published Events}

\begin{pubevent}{<http-request>}
  \argrow{timestamp}{timestamp from \code{erlang:now}}
  \argrow{pid}{handler process}
  \argrow{host}{the IP address of the client}
  \argrow{method}{\code{<request>} method}
  \argrow{path}{\code{<request>} path}
  \argrow{header}{a JSON object}
  \argrow{params}{a JSON object}
\end{pubevent}
